03
AOP aspects, аспектно ориентированное программирование:
АОП
    аспектно ориентированное программирование
    концептуально расширение ооп только для ортогональной функциональности

Представители Spring AOP и AspectJ

cross-cutting
    функциональность которая пересекает все слои приложения, ортоганальная или сквозная
    не является бизнес слоем или бизнес логикой
    именно она выносится в аспекты, для упрощения чтения бизнес кода
cross-cutting это:
1. логгирование
2. авторизация
3. обработка исключений
4. транзакции
5. кеширование
6. бенчмарк

Аспект
    класс который описывает сквозную логику для точки приложения,
        точка приложения описывается в самом классе
    есть spring aop, AsptectJ

Proxy
    jdk proxy
        проексирует только interface
        оборачивает только public
        работает быстрее cglib proxy

    cglib proxy
        проксирует class на основе наследования
        оборачивает public protected static constructor

Spring aop
    работает на основе proxy
    использует jdk proxy и cglib proxy
        хоть спринг и используется сторонние библиотеки, в конечно итоге
            код jdk proxy и cglib proxy будут преобразованны в spring aop формат и методы
    работает только с public и при вызове одно бина в другой
    (jpa не относится к spring aop)

weaving
    это процесс объединения кода аспекта и оригинального кода,
        на выходе получается модифицированный код
    виды
        compile time
            аспкты внедряются на этапе компеляции
            работает через плагины при сборке
            @Component не нужен
        load time weaving
            аспеты внедряются в класс на этапе загрузки в jvm
            работает через свой agent и aop.xml,
            можно также через механизм спринга включается через @EnableLoadTimeWeaving
            @Component не нужен
        runtime
            аспекты это бины внутри прокси, связываются при поднятии контекста
            @Component обязателен
            работает через зависимость aspectj-weaver
            используется в Spring

Advice
    метод в котором содержится код аспекта

JoinPoint
    место к которому нужна дополнительная сквозная функциональность
    обычно это вызов метода

PointCut
    правило, по которому происходит применения advice к joinPoint

Что бы заработало:
    @Aspect @Component и до spring boot 2.1 @EnableAspectJAutoProxy

@Order
    в параметры передается номер в котором должен выполниться
    если применяется к аспекту, то аннотация позволяет определить
        приоритет применения advice к joinPoint
    авторизация должна быть с самым высоким приоритетом
        потому что если например логирование до, то можно заполнить
            память логов при атаке
    бенчмаркинг должен быть максимально близко к месту тестирования

@EnableAspectJAutoProxy
	на классе конфигурации, включает работу с самописными аспектами

@Aspect
	ставиться на класс в котором реализованы методы с функционалом
	аннотация которая нужна для того что бы аоп заработал
	на класс с @Aspect должен ставиться @Component,
	    аспекты это тоже бины(когда spring aop)
	Хороший тон, делать аспект с аннотацией и помечать ней то что нужно обернуть

Pointcut
	работает только с публичными методами
	это выражение в (""), и есть язык написания запроса для аспектов
	method_name(..) метода с любыми параметрами
	* перед package_name публичные методы
	* на классе или методе это все в пакете или в классе, классы или методы

	execution
	    применяется ко всем публичным методам, по сигнатуре
	within
	    ко всем публичным методам, по сигнатуре, если
	        @within, то которые имеет над собой заданную аннотацию
	target
	    ко всем публичным методам, по типу инстансу, если
	        @target, то которые имеет над собой заданную аннотацию
	    рекомендованн к использованию @target
	this
	    ко всем публичным методам, по типу прокси
	bean
	    ко всем публичным методам, по id бина
	args
	    ко всем публичным методам, по сигнатуре аргументов, если
	        @args, то которые имеет над собой заданную аннотацию
	@annotation
	    все публичные которые имеют над собой заданную аннотацию
	    рекомендован к использованию

	"execution(* name_package.class_name.method_name(..))"
		публичные методы в классе с любимыми параметрами
	"execution(public Type_return package_name.class_name.mehtod_name(type_params))"
		публичный конкретный метод с конкретными параметрами
	"execution(* package_name.class_name.*(..))"
		публичные методы к классе с любыми параметрами
	"execution(* package_name.*.*(..))"
		все классы с публичными методами с любыми параметрами
	"within(package_name.class_name)"
		публичные методы к классе с любыми параметрами
	"within(package_name.*)"
		все методы внутри классов внутри пакета
	"target(package_name.interface_name)"
		все методы в классах реализующих этот инерфейс
	"@target(package_name.interface_name)"
		все методы в классе помеченные аннотацией
	"@annotation(package_name.interface_name)"
		методы помеченные аннотацией

Виды advice:
@Before
	("условие")
	ставитсья на метод в классе который помечен @Aspect
	вызов будет только до вызова оригинального метода из "условия"
	на вход приинимает joinPoint

@After
	вызов после точки входа(даже после исключения)
	на вход приинимает joinPoint

@Around
	до и после точки входа
	на вход приинимает ProceedingJoinPoint
	joinPoint.proceed(); вызов оригинального метода + return obj;

@AfterReturning
	после точки входа, если завершилась корректно
	на вход приинимает joinPoint

@AfterThrowing
	(pointcut = "условие")
	(throwing = "error") и в параметрах метода Throwable error
	в случае исключения в точке входа
	на вход приинимает joinPoint
