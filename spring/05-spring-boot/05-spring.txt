05
Область видимости Bean:
singleton
    1 на все приложение
    поведение по умолчанию
prototype
    в каждый бин свой собственный объект, создается когда зависимость потребует этот бин, в момент вызова
	не спасает от проблем с thread-safe
	иногда используется для кешов, утилитных классов
request
    на каждый web запрос свой бин
	спасает от проблем с многопоточность
	используется при аутентификации
session
    на каждую servlet http-сессию свой бин
	используется для корзины покупок, настроек пользователя
webSocket
    создается на каждую webSocket сессию

@Scope
    ставить на класс или метод позволяет объявить область видимости для бина
	("область_видимости") или (value = "область_видимости") объявляет область видимости бина
	(proxyMode = ScopedProxyMode.INTERFACES)
	    ставиться на request, session бине, работает через jdkProxy
	    создает пустой прокси для внедрения в бины где он нужен,
	        когда бин будет создан по указанной области видимости,
	            то пустой прокси его найдет по тредлокал и будет использовать

	(proxyMode = ScopedProxyMode.TARGET_CLASS)
	    тоже самое только работает через cjlib

Этапы создания бина:

init
	вызывается после afterPropertiesSet, все зависимости бина будут проинициализированны
	при тестах с этим методом без поднятия контекста, нужно его вызывать
	при тестах с контекстом не нужно
	используют обычно для
		соединения с БД или кастомным ресурсам
		 получения методанных сервиса
@PostConstruct
	ставиться на метод который у бина станет методом init
или
можно унаследоваться от InitializaingBean и переопределить метод afterPropertiesSet()

destroy
	вызывается при корректом завершении программы
	используется для закрытия доступа к ресурсам
@PreDestroy
	ставиться на метод который станет destroy методом
или
можно унаследоваться от DisposableBean и переопределить метод destroy()


получения спринг контекста в бине:
	можно через @Autowired ApplicationContext
	так же унаследоваться от ApplicationContextAware и переопределить метод
	    setApplicationContext() и там засетить поле в класс,
	        класс наследник должен быть bean
	но так делать нельзя это нарушает IoC

Кастомизация бинов:
BeanPostProcessor - интерфей который имеет 2 метода postProcessBeforeInitialization и postProcessAfterInitialization
	используется для создания прокси для бинов, делать обертки, кастомные инжекты

Профили у бинов:
не бест практисес
@Profile
	("название_профиля") указывается профиль при котором должен быть создан класс
	ставиться на класс бин
	создает бин в зависимости от профиля

profiles yml
    Разделение по профилям в одном yml файле можно делать через ---

Spring Boot Test::

@SpringBootTest
    ставитcя на класс, позволяет писать тесты с поднятием контекста springboot
        поднимает весь контекст кроме бинов с @MockBean
    работает с аннотацией @MockBean
    Если есть бд то ее поднимет
    @ExtendWith(SpringExtension.class)
        без нее не будут работать тесты
        включена в @SpringBootTest с версии 2.2 (примерно)
        вариант для junit5
        @RunWith(SpringRunner.class) для версии junit4
    ищет класс с @SpringBootConfiguration(@SpringBootApplication) и обрабатывает ее
        искать будет строго выше по пактам(не на том же уровне) по всему проекту
            пока не найдет без разницы main или test папка
        что бы избежть этой ситуации есть 2 варианта
        1 разместить @SpringBootApplication в корне src/test/java/... но до мейн класса,
            конфигурация будет искаться с этого пакета
        2 сделать внутренний публичный статический класс с @Configuration внутри теста
            тогда за пределы класса поиск не уйдет и бины из этого класса
            сложатся в контекст
        3* можно сделать внутрений класс с @TestConfiguration внутри тестового класса
            не отменяет поиск @SpringBootApplication, но он может дополнить
            или переопределить бины контекста

@RunWith
	(SpringRunner.class) класс старта тестов
	аннотация для запуска тестов для JUnit4

@ExtendWith({SpringExtension.class})
	({SpringExtension.class}) класс старта тестов
	аннотация для запуска тестов для JUnit5

@MockBean
	создает мок мок бина над полем на которое установлена
	    который перед каждый тестом заменяет исходный бин
	используется для зависимостей которые используется в тестируемом бине

@Autowired
	используется в тестах для внедрения объекта который должен быть протестирован

@Configuration
	может использоваться на nested static классах,
		если создать в таком классе бины то только они попадут в контекст
	останавливает поиск @SpringBootConfiguration который в аннотации @SpringBootTest
	можно не создавать бины, а использовать @ComponentScan в котором указать
		конкретный пакет или класс с бинами для теста
	можно так же использовать с @Import(class_name.class) у этого класса должно быть задано имя
		в создании, а не сгенерированно автоматически

@SpringBootConfiguration
	ставить на класс с тестовой конфигурацией в этом же пакете где нужно сделать настройку
	позволяет создать свой контекст для теста

@TestConfuguration
	используется на классе
	если использовать на внутреннем классе,
		то позволяет подменить бин в контексе или дополнить контекст,
		не прекращает поиск @SpringBootConfiguration, это доп конфигурция,
		что бы работало нужно бин оверрацдинг ключить

@DispleyName
	("test_name_in_idea") будет оборажаться это имя вместо класса или метода
	ставить на класс или метод


События в спринге:
ApplicationEventMulticaster
	бин для переопределения асинхронности в событиях спринг
	реализацию гуглить под задачи

ApplicationEventPublisher
    публикует события

ApplicationEvent
    явлияется событием
    что бы создать событие нужно унаследоваться от ApplicationEvent

пабришер
	@Autowired ApplicationEventPublisher в свой класс где генерируется событие
	событие = new Событие(this, other params);
	метод для добавления собития applicationEventPublisher.publishEvent(событие);
слушатель
    что бы слушать событие нужно
        либо повесить над методом @EventListener в методе параметр(имя_класса события)
            предпочтительный вариант, ничего не знает о потрохах спринга
        либо стать наследником implements ApplicationListener<имя_класса_события>
            вариант не предпочтительный, знает о спринге и его кишках, нарушает IoC
	для использования нужна @Component


spring shell:
spring shell starter
	используется для вызова команд через командную строку

@ShellComponent
	ставить на класс
	набор методов

@ShellMethod
	(value = "описание команды")
	(key = {"command_name1", "command_name2"}) можно указать название команд на которые будет реагировать
	ставить на метод
	это набор команд
@ShellOption
	по умолчанию с 2.0.0 не обязательно, но есть важные параметры
	ставиться в параметры
	аргументы к командам, дополнительные аргументы передаются  --arg
@ShellMethodAvailability
	("method_name") можно передать метод который будет вызываться перед методом на котором стоит
	("command_name") если стоит на методе с проверкой,
		то нужно передать команды "command_name" для котоых включить проверку

	Availability.unavailable("massage") не прошел проверку, прервеи выполнение с message
	Availability.available() будет вызван основной метод
	позволяет управлять доступностью команд
	ставить на метод, с командой или проверкой

что бы отключить в тестах
spring:
  shell:
    interactive:
      enabled: false
