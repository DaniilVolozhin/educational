
08
ооп
    для описания сущности используеются классы
    каждая сущность это экземляр
    свойство сущности то поле
    поле класса тоже может быть сущностью
    между классами есть отношения
в бд
    в реляционных бд сущности хранятся в таблице
    каждая сущность строка
    каждое свойство сущности это столбец
    меду таблицами есть отношения
итог
    класс сущности отображается на 1 таблицу(в идеале)
    поля класса в основном мапятся на поля таблица
    если поле класса сущность то под нее есть таблица

impedance mismatch
    проблема сопоставления сущности и таблицы

ORM:
orm object relation mapping
    позволяет отображать сущности на бд и наоборот

jpa java persistence api
    набор аннотаций(и интерфейсов), для разметки классов-сущностей, которая
    	позволяет orm понимать как ей работать с классами
    реализация этого апи это hibernate, eclips link, open jpa

Минимальный набор для hibernate @Entity и @Id

@Entity
	говорит orm что этот класс - сущность
	orm считывает метаданные класса и генерирует запросы и тд
	если создание базы делается hibernate то название таблицы = имя сущности,
	    имя поля = имя колонки

@Id
	позволяет указать какое поле является идентификатором
	ставиться на поле класса
	используется для простого ключа

@EmbeddedId
	помечает поле как id
	ставиться на поле класса
	используется для составного ключа

@GeneratedValue
	позволяет для id указать стратегию генерации id
	GenerationType.:
		AUTO
		    автоматический выбор
			не рекомендуют, рваный id, повторения
		IDENTITY
		    на основе автоинкременого поля таблицы
		SEQUENCE
		    в базе на основе заданной последовательности(по умолчанию hibernate_sequence)
		TABLE
		    на основе заданной таблицы с значениями поля(по умолчанию hibernate_sequence)
			не рекомендуют, долго, читать базу, писать в базу

@Table
	(name = "name_table") name_table имя таблицы в бд
	задает имя таблицы с которой сопоставиться объект
	ставить над классом
	можно указать и другие параметры schema, indexes, catalog, uniqueConstraints

@Column
	задает имя колонки с которой сопоставиться поле класса
	ставиться на поле класса
	в ней можно задать ограничения nullable, unique, updatable и т.д.

@OneToOne
	используется для сущностей один к одному
	может стоять только в одном из классов связи
	fetch по умолчанию eager
	работает с @JoinColumn и в ней обозначается связующий столбец родительской сущности

@OneToMany
	используется для связи один ко многим
	может стоять только в одном из классов связи
	fetch по умолчанию lazy
	работает с @JoinColumn и в ней указывается связующий столбец в дочерней сущности
	так же можно испльзовать @JoinTable но это избыточно

@ManyToOne
	используется для связи многие к одному
	может стоять только в одном из классов связи
	работает с @JoinColumn

@ManyToMany
	используется для связи многие ко многим
	может стоять только в одном из классов связи
	fetch по умолчанию lazy
	работает с @JoinTable и связь осуществляется через таблицу связей

общие атрибуты аннотация со связями:
	targetEntity
	    почти никогда не используется
		определяет сущность на том конце связи
		ипользуется только когда не типизированный объект для связи

	cascade
		позволяет указать какие операции будут каскадно влиять на связанные сущности
		ALL, PERSIST, MERGE, REMOVE, REFRESH, DETACH
		нет значения по умолчанию

	fetch
	    как решили проблему n+1 и декартовом произведении в orm
		позволяет указать как необходимо загружать связи сущности
		eager - загружать сразу  дочернюю сущность, но в дополнительном запросе
		lazy - прокси вместо связи, вызов метода отправит запрос в бд

	orphanRemoval
		удаляет дочернюю сущность, когда связь с родителем удаляется

	mappedBy
		используется для двунаправленной связи(получение связанных объектов из друг друга)
		дока хибернейта рекомендует проставлять

@JoinColumn
	(name = "fk_name") используется для генерации\указании столбца c
	    внешним ключом с названием fk_name
	ставиться на поле класса
	есть много дополнительных параметров ForeignKey и тд
	в один к одиному ключ добавиться в родителя
	в один ко многим ключ добавиться в дочерней класс
	в многие к одному ключ добавиться в дочерней класс

@JoinTable
	(name = "many_to_many_table_name)
	    указать имя таблицы в которой будут храниться связи
	(joinColumns = @JoinColumn(name="fk_this_class_name_id"))
	    указать имя колонки внешнего ключа для этой таблицы
	(inverseJoinColumns = @JoinColumn(name="fk_имя_связаной_таблицы_id"))
	    указать имя колонки с внешним ключом связанной сущности
yml:
spring:
	jpa:
		hibernate:
			ddl-auto: create
			    позволяет указать как hibernate нужно управлять структурой базы в зависимости от метаданных сущности
		properties:
			hibernate:
				format_sql: true
					хибернейт выводит sql отформатированным

Api JPA:
JPA
	прослойка меджу кодом и orm фреймворком, провайдер hibernate

Тут появляется парадигма репозиториев
@Repository
    ставится на класс который будет работать с объектами в бд
    в него инжектится через @PersistenceContext EntityManager
        который предоставляет апи для работы с базой

Persistence
	информация о сохраненности объектов в базе

EntityManager
	работает с объектами согласно persistence
	основной класс в котором происходит работа
	создает запросы query
	в моменте имеет только 1 entityTransaction
	методы и их значения:
        persist()
            добавление сущности в бд,
                сохранение(работает как upsert или добавление нового объекта)
        merge()
            обновить сущность в бд, смержить state в persist state
        remove()
            удалить сущность
        find()
            поиск и загрузка сущности
        lock()
            блокировка, писсимистичная, есть еще version(оптимистичная)
        refresh()
            persist state в state
        detach()
            отключить state от persistence context
        uptach()
            подключить state в persistence context
        createQuery()
            создание запроса через jpql

EntityTransaction
	работает с транзакционностью объектов

EntityManagerFactory
	отвечает за метаданные, содержит инфу и persistence

@PersistenceContext
	работает как @Autowired, для класса EntityManager
	в spring orm thread-safe entityManager

State Entity:
	persist state - сохраненное состояние объекта
	state - состояние текущего объекта
	обязанность orm синхронизировать 2 этих состояния

методы EntityManager:
	find - поиск и загрузка сущности
	persist - добавление сущности в бд
	merge - обновление сущности в бд
	remove - удаление сущности
	createQuery - создание объекта запроса

JPQL:
	позволяет писать query в ооп стиле
	использоватьс typedQuery
	для добавления параметров setParameters которые в query :param
	для опреаций не на чтение делать executeUpdate()

test jpa:
можно мокать entitymanager, entitytransaction, query

Итог
    весь sql в маппинге entity
    entity бизнес слой
    dao теперь репозиторий, и тоже на бизнес слое
    плюсы
        позволяет оперировать бизнес сущностями
        позволяет абстрагирвоаться от sql и диалектов(не всегда)
        с jpa позволяет абстрагироваться от orm провайдера
        меньше кода
    минусы
	    производительность падает из за рефлексии и прочей магии
	    нет возможностей плюшек в бд и нет доступа к нативному sql бд


MyBatis:
	другой подход к организации orm фреймворка
слой сущностей пустой, вся настройка делается через слой Repository



@Select
	("query") в параметрах пишется запрос для получения объекта
	синтаксиси как spel, параметры в запрос берет из параметров метода
	ставиться над методом класса
@Insert
	("query") пишется запрос для инсерта в таблицу
	синтаксиси как spel, параметры в запрос берет из параметров метода
	ставиться на метод класса
@Update
	("query") пишется запрос для обновления данных в таблице
	синтаксиси как spel, параметры в запрос берет из параметров метода
	ставиться на метод класса
@Delete
	("query") пишется запрос для удаления данных в таблице
	синтаксиси как spel, параметры в запрос берет из параметров метода
	ставиться на метод класса

@Results
	(id = "name_map") указывается название маппинга
	(value = {@Result(...),...} тут указывается сопоставление полей для класса с бд
	ставиться над методом класса
@Result
	(property = "object_field_name") название поля класса будет маппиться на column
	(column = "table_column_name") указывается имя колонки из select будет маппиться на property
	(javaType = Name_class.class) если поле объект указывается его класс
	(one = @One(...)) указывается тип связи
	(many = @Many(...)) указывается тип связи
	(many = @Many(...)) указывается тип связи
@One и @Many
	(select = "package.class_name.method") метод для получения связи
	(fetchtype = FetchType.) EAGER, LAZY как получать связанную сущность

@ResultMap
	("name_map") указывается маппинг с другого метода, как смапить sql и java
	ставиться на метод класса


