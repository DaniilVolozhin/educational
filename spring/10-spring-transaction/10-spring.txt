10
Транзакционность

Транзакционность в бд:
транзакция
    набор последвательных операций с базой данных, которые соединены в 1 логическую

A
    атомарность, либо все действия операции выполнены, либо никакие
C
    согласованность, при выполнение операции не будет нарушена целостность таблиц
I
    изоляция, позволяет работать с изменениями данных в условиях конкуренции к данным
D
    долговечность, если операция выполнена, то результат сохранился

commit
    база находится в консистентном состоянии 1
    выполняютя операции с сущностями базы, из одной колонки вычитают и в другую прибавляют
        в рамках 1 транзакции
    при успеном завершении транзакции база перейдет в консистентное состояние 2

rollback
    база находится в консистентном состоянии 1
    выполняютя операции с сущностями базы, из одной колонки вычитают и в другую прибавляют
        в рамках 1 транзакции
    транзакция будет отката и база вернется в состояние 1

паралельные транзакции
    база находится в консистентном состоянии 1
    запускается транзакция 1 и выполняютя операции с сущностями базы,
        из одной колонки вычитают и в другую прибавляют в рамках 1 транзакции
    запускается 2 транзакция которая будет вычитать их той же колонки что и транзакция 1
        транзакция 2 будет заблокированна пока транзакция 1 не завершит работу

Типы транзакций:
local
    транзакция в одном DataSource
Global
    транзакция в нескольких DataSource
    обычно управляются используя JTA (Java Transaction API)
        для jta использутся transaction dispatcher который контролирует и гаранитрует
            корретное выполнение всех связанных транзакций
        в блокчейне тоже используется transaction dispatcher, но который
            является распеределенным
транзакции могут использоваться в jms(java message system)

неявные
	insert, update, delete являются единицей транзакции
явные
	операции к которым надо писать begin, transaction, commit, rollback

Изоляции транзакций
    очень дорогие операции для бд
    по идее операции должны выполнятся польностью изолированно,
        но тогда очень низкая скорость, для решения этой проблемы придумали уровни изоляции
        и транзакции уже не последовательны и появляются side-эффекты

Уровни изоляции транзакций:

no transaction
    проблема с потерянным обновлением
    возникает когда есть
        2 транзакции, транзакция 1 и транзакция 2, работают одновременно
        одни и те же данные которые изменяют 2 тразнакции одновременно
        в результате та транзакция которая закончит позднее не учтет действия
            другой транзакции которая закончит раньше
    все уровни ниже не имеют проблемы с потерянным обновлением

read uncommited
    чтение незакомиченного, решает проблему потерянного обновления
    проблема грязного чтения
    грязное чтение
        каждая транзация видит незафиксированные изменения другой транзакции

read committed
    чтение закомиченного, решает проблему грязного чтения
    проблема неповторящееся чтение
    неповторяющееся чтение
        2 транзакции читают одну запись, транзакция 1 читает запись, транзакция 2
            транзакция тоже читает запись, транзакция 1 вычитает из значения записи,
            транзакция 2 тоже вычитает из значения записи, но после работы транзакции 1
            значение записи изменлось и вычитание транзакции 2 приводит базу в
            неконсистентное состояние и откатывается, хотя на момент чтения
            она могла быть выполнена
        при повторном чтении в рамках второй тразакции данные не совпадут
            с изначальным значением

repeatable read
    повторяемое чтение, решает пробему неповторяющегося чтения
    проблема фантомное чтение
    фантомное чтение
        2 транзакции работают одновременно, транзакция 1 пишет в таблицу,
            транзакция 2 читает таблицу, транзакция 2 прочитывает после чего транзакция
            1 записывает и делает коммит, после чего транзакция 2 делет какие то
            действия и тоже делает коммит, записи тразакции 1 не были обработанны

serializable
    сериализованное чтение, все транзакции выполняются последовательно

Блокировки:
Оптимистичная блокировка
	две опреции меняют один данные, первая операция завершилась,
	вторая будет вынуждена перечитать изменения и смержить их
Пессемистичная блокировка
	одна операция блокирует ресурс,
	вторая операция сможет с ним работать только когда первая освободит

Spring Tx:
    Модуль для управления транзакциями
    ключевой класс управляющий тразакциями TransactionManager
	имеет много реализация для разных технологи, jdbc, jpa и тд
	декларативное управление через @Transactional
    императивное управление через TransactionTemplate
    есть spring-boot-starter-tx который все сам сконфигурирует
        spring-boot-starter-tx включает TransactionManager для каждой транзакции
    по умолчанию при работе с EntityManager открывается транзакция с readOnly=true

TransactionManager
    ключевой класс который занимается управлением транзакциями
    DataSourceTransactionManager, HibernateTransactionManager и другие

propagation у транзакций будет работать только при вызове другого бина,
    аоп так работает

@Transactional
    работает через aop
	используется для включения транзакции для указанного класса или метода
	может ставиться на класс, если на классе то все публичные методы будут
	    обернуты в транзакцию
	может ставиться на публичный метод, транзакцией будет покрыт весь метод
	может ставиться на интерфейс и его методы
    лучше всего ипользовать на сервисном слое так как
        он знает что нужно делать в транзакции, но если делаем что то атомарно,
        то ставить на репозиторий уместно
	(readOnly = boolean)
	    true - для чтения из бд, обходится дешевле для бд
	    false - по умолчанию, для прочих операций
	(propagation = Propagation.*)
        у транзакций будет работать только при вызове другого бина, аоп так работает
	    для работы с вложенными транзакциями
		REQUIRED
		    если транзакция 1 есть, то использует ее, или создает новую
		    No  T2
		    T1  T1
		REQUIRES_NEW
		    всегда создает новую транзакциюя, не вложенную, отдельную
		    No  T2
		    T1  T2
		MANDATORY
		    использует транзакцию или если ее нет транзации то бросает exception
		    No  error
		    T1  T1
		NOTSUPPORTED
		    приостанавливает текущую транзакцию, не начинает новую
		    No  No
		    T1  No
		SUPPORTS
		    использует текущую, не открывает новую
		    No  No
		    T1  T1
		NEVER
		    если запускается транзакция бросет исключение
		    No  No
		    T1  error
		NESTED
		    создает транзакцию, новую или вложенную
		    No  T2
		    T1  T2(внутр)
	(timeout)
	    сколько времени есть на исполнение транзакции
	(isolation)
	    уровень изоляции для этой транзакции
	(rollbackFor = name_checked_Exception.class)
	    если runtime exception то делается rollback
        если checked exception то commit
            ожидается что если кидается checked то разработчик знает о ней и должен
                сам ее обработать
        если будет sqlexception(checked) для data jpa откат, так как
            он кинет свой unchecked, для других смотреть надо
	(noRollbackfor = name_exception.class)
	    указать при каком exception не надо откатывать
