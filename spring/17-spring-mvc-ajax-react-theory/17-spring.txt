Spring MVC:

скопы бинов
@Scope
    value
        значения которые появляются в spring-mvc:
            request
                proxyMode обязательно должен быть заполнен
                    ScopedProxyMode.TARGET_CLASS
                создается на каждый request
                в таком бине будет храниться:
                    securityContext
                    locale пользователя
                    thread-safe классы
            session
                proxyMode обязательно должен быть заполнен
                    ScopedProxyMode.TARGET_CLASS
                создается на каждую сессию
                в таком бине хранят:
                    настройки пользовтеля
                    security данные
                    данные форм
                    cross-page данные(данные живущие через все страницу)
                работает поверх j_session_id
                сессии управяются контейнером (tomcat)
                что бы получить session можно получить HttpSession объект в параметры
                    контроллера

Spring Web Flow:
    используется для работы с сессионностью на разных страницах и
	    позволяет хранить данные между страницами
    работает через xml

Классические приложения:
    рендеринг на стороне сервера
    на каждую страницу новый вызов
	html c данными для каждой страницы, генерируется сервером
	js подключается в html, анимирует html с данными
	css подключается в html, задает стиль отображения
	можно получить документ /get.html

AJAX(asynchronous Java Script and xml):
	небольшая статическая html с кодом js, который загрузит данные с сервера
		допольнительным запросом в формате json
    сервер может отдавать как данные так и страницы
	работает через html к которому подключется js и css
	есть ресты для получения формы html и есть ресты для получения json с данными они
	    могут быть на разных серверах и разных языках

SPA(single page application):
    1 статический html с подключением js, приходит с например с nginx,
        js управляет всем визульным
	вы остаетесь на одной html странице
	все остальное наполнение(данные) через запросы на сервер
	нет запросов клиента для получения форм


REST(representational state transfer):
    это архитектурный стиль, не стандарт
    набор принципов и ограничений, что не нужно сделать
    принципы:
    Единый интерфейс
        определяет взаимодействие между клиентом и сервером
        основан на ресурсах
            uri зависит от ресурса, поэтому по uri понятно с каким ресурсом работаем
        манипуляция над ресурсом
            понятно как делать операции с ресурсом
        самодокументируемые сообщения
            с заголовках есть информация как обработать
        hateoas
            могу быть ссылки на ресурсы
    Отсутсвие состояния
        необходимые данные для обработки запроса содержаться в самом запросе
        не хранятся данные на сервере, в том числе и промежуточные состояния
    Кеширование ответа
        то есть клиент может кешировать ответ, что бы уменьшить обращения
    Клиент сервер
        клиент не завязан на конкретном сервере, может обращаться на любой
    Многоуровневая система
        клиент не знает общается ли он с сервером на прямую или через прокси
    Код по требованию
        сервер может отдавать код клиенту для исоплнения
    плюсы
        надежность
        производительность
        масштабируемость
        простота интеграции
        микросервисная архитектура

