Реактивное программирование:

ReactiveX
    стандарт как писать реактивные программы
    стандарт для библиотек
    содержит манифест


реактивное программирование
	мы реагируем на какое то событие, мы не ждем пока нам ответят
	ориентированно на сообщения (message Driven)
	реактивное приложение должно быть:
		эластичным(elastic, отвечать нагрузке)
		устойчивым(resilint, восстанавливаться после нагрузки)
		реагирующем(responsive, отвечать на запросы в какое либо ограниченное время)
	это call-back написанный хорошим способом
	все реактивное программирование ленивое, если не подписаться, то не будет выполнения

ReactiveX
	стадарт как надо писать на реактивном программирование

JavaRx:
    библиотека которая реализует стандарт reactiveX

Callback
    полезная работа которая должна быть выполнена при наступлении условий выполнения

Message
	сообщения, данных которые куда отправляем. не работаем напрямую(заказ)

Observer
	наблюдатель, тот кто наблюдает за статусом события(человек)

Observable
    в rxJava2 это будет Flowable(с поддержкой backpressure)
    на этот объект мы вополняет подписку(.subscribe(тут лямба с логикой подписчика)
        для получения событий которые будут опубликованны, так же можно и
        отписаться от события через Disposable.dispose() объект получается при подписке
    ленивая реализация, отправляет данные только при наличии подписчиков

    холодный Observable
        источник данных создается внутри observable
        выполнение observable не происходит пока мы не подпишемся на него
            ленивая реализация, отправляет данные только при наличии подписчиков
        для любого подписчика отдаст одни и те же данные

    горячий Observable
        оберка над внешним источником данных
        данные приходят независимо от того есть подписчики или нет
        можем преобразовать один тип observable в другой

Subscription
	подписка на событие, когда следишь за событием, то это подписка на
	    событие(человек смотрит)

Subscriber
	observer + subscription. подпичсик который сам управляет своей подпиской

Subject
    сам является подписчиком и позволяет подписаться на себя
	observer + observable. наблюдает за событием и за ним можно наблюдать
	позволяет отправлять новые эвенты(значение) в observable после их создания

ObservableTransformer
    интерфейс
    используется для метода который будет содержать общую логику для обработки Observable

backpressure
	названия явления, когда событий генерируется больше чем обрабатывается
	есть способы задать обработку
	обратное давление


