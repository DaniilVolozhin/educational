Reactive Spring:
    все реактивное програмиирование ленивое, необходимо подписываться на результат
    в коде мы не создаем обсервабл и не подписываемся на них,
        мы получаем и возращаем их от сервисов и репозиториев, а подписывается
            spring reactor
    подходит
        когда есть много не больших эвентов(запрсов)
        когда нужно быстро дать ответ
        когда большая нагрузка
    не подходит
        когда долгие запросы
    stack:
        Netty(Tomcat реактивный с донастройкой + servlet api 3.1)
        Project Reactor
        Spring Data Reactive Repositories
        Spring WebFlux
        Spring Reactive Security
    под большой нагрузкой:
        реактивное приложение:
            время ответа увеличивается, но успешные ответы продолжаются
            не успешные запросы появляются, когда запросов становится слишком много,
                но приложение все еще работает, но ответы долгие
            нагрузка повышается равномерно с ростом кол-ва запросов
        не реактивное приложение:
            кол-во не успешных запросов растет, в момент когда достигнута точка
                максимальной мощности приложение падает
            кол-во успешных ответов почти нет, так как приложение зависает

Spring WebFlux:
	аналог spring mvc, но реактивный
	работает на основе event loop

Event Loop
    предисловие:
        у нас есть 1 поток, который крутиться в бесконечном цикле while true
        есть очередь событий, которую обрабатывает 1 поток
    действие:
        когда поток берет событие и выполняет работу которую описана в событии(код
            subscribe метода)
        если код будет блокирующим, ожидание чего то, то поток перестанет делать
            полезную работу
        если код будет не блокирующим, ожидание чего то, то создается новое событие с
            этим ожиданием и кладется в очередь
    вывод:
        что бы поток работал все время, все операции на ожидание должны быть созданы как
            событие и кластся в очередь
        есть очередь событий для обработки событий
        событие содержит код(коллбек) который должен быть выполнен

Single
	для возврата единичного значения в реактивном формате

Flowable
	для возврата множества в реактивном формате

Netty:
    фреймворк для сетевых протоколов
    поддержирает большинство сетевых протоколов
    реализует протоколы на неблокирующей основе
    non blocking http клиент и socket

Project Reactor:
    соответствует идеологии rxJava
    это фреймворк для построения реактивных приложени
    можно использовать не в реактивном стеке для добавления
        реактивной обработки
    это reactive stream, добавляет
        mono
            аналог single из rxJava
            один элемент
            реактивный optional
            усточивость к backpressure
            spring webflux поддерживает работу с этим классом
        flux
            аналог flowable из rxJava
            множества в реактивном формате
            усточивость к backpressure
            spring webflux поддерживает работу с этим классом

produces = MediaType.TEXT_EVENT_STREAM_VALUE
	если использовать этот тип то будет открыто что то вроде веб сокет
	означает что не надо закрывать соединения, данные будут досылаться
	дорогое подключение, по сути http подключение к серверу


Reactive Spring Data:
    jdbc синхронный, не поддерживается
    r2dbc
        асинхронный драйвер к реляцонным базам с ограничениями
        уже есть реализации для
            postgresSql
            h2
            ms sql
    из коробки поддерживаются
        mongo
        redis
        cassandra
    обычно основная точка отказа это база данных, поэтому мы не может тормозить event
        loop не реактивной базой данный

Reactive-repository-mongo:
@EnableReactiveMongoRepository
	включает реактивный репозиторий для монго
    для создания репозиториев
        extends ReactiveMongoRepository<?,?>
    кроме наследования от реактивного репозитория все остальное выглядит так же
    параметры метода можно передать как Flux, Mono


Reactive Transaction
	работает через @Transaction так же как и в не реактивном
	или через template.inTransaction().execute()
