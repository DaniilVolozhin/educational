Spring-boot-actuator:
позволяет работать с: healthchecks, metrics, admin methods(shutdown)

открывается по host:port/actuator

Минусы микосервисов:
1. Сложнее мониторинг
2. Разные языки, сложности с конфигурацией
3. Сложнее развертывать, системы настройки развертывания
4. Могут быть проблемы с безопасностью

плюсы:
1. повышение доступности и отказоустойчивости
2. повышение надежности, в случае ошибки упадет только часть системы
3. Легче тестировать




путь HttpRequest со Spring Security:
реализации будут зависеть от выбраного типа аутентификации
-> вызывает
httpRequest ->
BasicAuthenticationFilter ->
AuthenticationManager(выполняет аутентификацию, создает фейк реализацию Authentication)-> 
ProviderManager ->
AuthenticationProvider(конкретная реализация аутенификации) ->
UserDetailsService(получает UserDetails) -> 
AuthenticationProvider(проверяет пароль на совпадение(через сравнение закодированных),
	задает реальный Authentication) ->
BasicAuthenticationFilter(если authenticated false, то ошибка)(если true то пишем в) -> 
SecurityContextHolder


PasswordEncoder
	функция кодирования пароля
	создается как бин
	к функциям хеширования небходимо добавлять солья

AbstractSecurityInterceptor
	занимает авторизацией

AccessDesicionManager
	примает решение о доступе к функционалу приложения, обработка доступов у авторизации

FilterSecurityInterceptor
	Управляет доступом на уровне URL
	Использует цепочку HTTP фильтров для управления доступом

MethodSecurityInterceptor
	Управляет доступом на уровне методов класса
	Использует Spring AOP


@EnableWebSecurity
	включает создание и конфигурацию бинов


spring security web:
работает через servlet filter

DelegatingFilterProxy
	передает вызов в цепочку фильтров security

WebSecurityConfigurerAdapter
	настраевает цепочку фильтров
	порядок фильтров в цепочке можно сконфигурировать(очень осторожно)
	configure(WebSecurity) какие пути мы игнорируем для security
	configure(HttpSecurity) настраевает фильтры для security


Работа в конфигурационном классе:
.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.*)
	указывается какое состояние должно быть у SecurityContext,
		по умолчанию SecurityContext хранится в сессии
	ALWAYS всегда создает httpSession
	NEVER не создает httpSession, но использует если она есть
	IF_REQUIRED создаст httpSession если это необходимо
	STATELESS никогда не создаст httpSession и не будет ее использовать


Form-based:
нужно использовать только в https
.formLogin()
	включит аутентификацию form-based

.loginProcessingUrl("url")
	настраевается url для аутентификации
.usernameParameter("")
	настроевается название параметра username в запросе который мы ожидаем
.passwordParameter("")
	настроевается название параметра password в запросе который мы ожидаем
.loginPage("url")
	настраевается сраница или url для аутентификации. ("/login.html")
.defaultSuccessUrl("url")
	куда перенапрявлять в случае успеха, если нет изначальной запрашиваемой страницы
.successForwardUrl("url")
	всегда перенаправлять в случае успешной авторизации
	не понятно как работает
.failureForwardUrl("url")
	куда перенаправлять в случае ошибки

.and().logout("url")
	настраевается url для разлогина


JSESSION
	сессионный ключ, который создаёт сервлет контейнер для хранения сесси
	хранится как ключ значение
	security context связывает разные запросы по jsession, что бы не пересоздаваться




Http-basic:
login, password передаются в поле загаловка Authorization в закодированном виде,
	отправляется в каждом запросе
Используется без сессионности на сервере
нужно использовать только в https
уязвим для in the midle

.httpBasic()
	включить аутентификациюю http-basic, других настроек нет


Anonumous Authentication:
вторичная аутентификация
запускается после первичной аутентификации
есть доступные ресурсы, по ним нужно иметь заполенный контекст, для этого анонимная аутентификация,
	которая заполяет контекст. Аноним с самыми дохлыми правами

.anonumous()
	включить анонимную аутенификацию
.authorities()
	назначить права анонимному пользователю
.principal()
	назначить имя анонимному пользователю
	или можно передать класс анонимного пользователя

Remember-me-authentication:
	позволяет сохранять информацию о пользователями между http сессиями
	обычно через cookie в браузере
	работает только с form-based auth

работает на:
подход simple hash-based token
	(username + ":" + expirationTime(соль) + ":" + 
		md5Hex( username + ":" + expirationTime + ":" + password + ":" + key))
	jwt токен реализация подхода
	можно поменять key и все сесии разлогинит
	токены храняться в хранилище, досупны по суррогатным ключам(значения из cookie)
или
подход persistent Token 

form-based + 
.rememberMe()
	включить запоминание между сессионное
.key("key")
	указать ключ к token
.tokenValiditySeconds(time)
	время жизни токена

тестирование с ролями:
spring security test
@WithMockUser
	(username = "name") указывается имя пользователся с которым будет запущен тест
	(authorities = {"role"}) указываются права пользователя с которыми будет запущен тест


Авторизация:
acl
	доступ на основе бизнес сущностей

ролевая модель
	представляют из себя строчки, обычно сравнивается через equals
	набор ролей это GrantedAuthority(можно и сделать свой сложный объект)
	обычно права пользователя после аутентификации сохраняются в кеш из которого 
		потом читаются для выдачи доступов
	называются ROLE_ADMIN, ROLE_ANONYMOUS, ROLE_USER, в каких то классах 
		записываются ADMIN, USER и ROLE_ добавиться автоматически
		hasRole("ADMIN"), hasAuthority("ROLE_ADMIN")
	ролевая модель по умолчанию плоская, но можно сделать иерархичную
		@Bean RoleHierarchyImpl
	
AcessDecisionManager
	осуществляет проверку прав, опирается на GrantedAuthoritys
	наследники AcessDecisionManager
		AffirmativeBased
			если один сказал да, то доступ есть. По умолчанию
		ConsensusBased
			каких голосов больше то такой доступ и будет.
		UnanimousBased
			если один сказал нет, то запрещаем доступ
	наследники будут опрашивать Voter классы что бы принять решение

AcessDecisionVoter	
	класс который проверяет наличие необходимой роли у пользовтеля
	можно написать своб реализацию


для настройки security config важен порядок следования, сверху вниз, от конкретных
	к более общим паттернам, иначе не будет работать как задумано

.authorizeRequests()
	ставить перед настройкой antMathchers()

.antMatchers
	("url")
	указывается url, или паттерн для которого необходимо выполнить действие авторизации
		паттерн пишется через *, одна * означает обязательно один уровень вложенности
		две ** обязательно один или более уровней вложенности

.anonymous()
	дать доступ к ресурсу тем у кого есть анонимная роль

.authenticated()
	дать доступ тем кто прошел аутентификацию

.hasAnyRole("role1", "role2"...)
	дать доступ тем кто имеет одну из ролей

.hasAuthority("ROLE_*")
	дать доступ тому что имеет роль

.denyAll()
	все что по паттерну явно не разрешено запрещено

Авторизация на основе вызовов методов:
эта авторизация не до spring web, она основана на AOP

@EnableGlobalMethodSecurity
	(securedEnabled = true) включить работу с аннотациями  @Secured
	(prePostEnabled = true) включить работу с аннотациями @PreAuthorize, @PostAuthorize,
		@PreFilter, @PostFilter
	настраевает бины для работы, ставить на конфигурационный класс

MethodSecurityInterceptor
	основной бин для работы


@Secured
	("") можно передать необходимую роль(ROLE_*) для доступа
	ставить на метод, класс
	работает через прокси над сервлетом после авторизации
	нет поддержки SpeL выражений
	в некоторых ситуациях лучше не использовать с ролями, и записать это в SecurityConfig

@PreAuthorize
	("spel") указывается выражение с необходимыми правами доступа
		hasPermission(#objectParamMethod, 'READ') есть ли у пользователся из securityContext
			право чтения этого объекта, если нет то ошибка доступа
		hasRole('ROLE_*') если имеет указаную роль то получит доступ к методу
	если нет необходимых прав то кидается AcessDeniedException
	позволяет определить права для вызова метода
	работает со SpeL выражениями

@PreFilter
	(value = "spel")
		hasPermission(filterObject, 'READ') объект в параметрах метода будет отфильтрован и
			только те объекты в коллекции которые у данного пользователся c READ
			будут переданы в метод, как новый список
	(filterTarget = "nameObjectParamMethod") указывается название параметра для фильтрации
	выполняет фильтрацию коллекции в параметрах метода по правам доступа

@PostAuthorize
	("spel")
		hasPermission(returnObject, 'WRITE') у возвращаемого значения проверить право на запись
		для ссылки на возвращаемое значение используется returnObject
	работает с возращенным объектом из метода и проверяет права на его использование

@PostFilter
	("spel")
	hasPermission(filterObject, 'READ') отфильтровать и оставить только те что с правом чтения
	выполняет фильтрацию выходных значений


Spring securty acl:
ACL acess contol list:
	концепт предоставления доступа
	для работы с acl spring security создает в базе допольнительный таблицы для хранения прав
	и объектов: acl_object_identity(инфорамция о всех сущностях в системе),
		acl_class(идентифицирует сущность),
		alc_sid(идентифицирует тип владельца), acl_entry(права владельца к сущностям системы)
	возможность чтения acl для всех сущностей
	оптимизированный механиз чтения
	использование кеширования
	возможность проверки перед вызовом и после вызова
	


Permission
	spring security использует битовые маски для обозначения прав доступа
		0 read, 1 writr, 2 create, 3 delete, 4 administer

Ключевые классы:
Acl
	список управленя доступок который определеяет кто или что может получать доступ к объекту
MutableAcl
	реализация в которой можно модифицировать acl
AccessControlEntry
	содержит объект с разрешением
Permission
	разрешение
Sid
	идентифицирует учётную запись пользователя, интерфейс с equals и hashCode методами
ObjectIdentity
	предоставляет уникальную идентификацию сущности
AclService
	вся логика заложена тут
MutableAclService
	что бы работатьь с измененой acl
AclCache
	кеш

Spring Security Reactive:

@EnableReactiveWebSecurity
	конфигурация и подключение бинов security для реактивности



Spring Batch:
	содержит абстракции для пакетной обработки данных

etl extract transform load
	извлечение, преобразование, загрузка
	из источнков к общему виду в другие источники


job
	абстракция работы, содержит описание шагов из которых состоит обработка
step
	шаг работы
	может быть чтение данных из источника, преобразование, отправка
item
	элемент обработки
	строчка в бд, объект и т.д.
chunk
	пачка элементов который будут обработаны за раз

tacklet
	единичное действие на выполнения, где не нужны трансформация


Job:
создается через @Bean Job
для создания есть builder

JobBuilderFactory
	фабрика для создания билдеров job
	ее нужно сделать @Autowired
.get
	("name_builder_job") получить у фабрики билдер с названием name_builder_job

.start
	(object) передается объект для выполнения
		step - для последовательной обаботки
		flow - для паралельной обработки

.next
	(object) следущий объект для выполнения

.end
	закончить

.listener
	(object) задается объект методы которого будут выполняться в результате выполнения стадий job
		ItemReaderListener(beforeRead, afterRead, onReadError) для чтения
		ItemWriterListener(beforeWrite, afterWrite, onWriteError) для записи
		ItemProcessListener(beforeProcess, afterProcess, onProcessError) для записи
		ChunkListener(beforeChunk, afterChunk, onChunkError) для chunk

.taskExecuter
	(object) можно передать выполнятель для паралельной работы task

.build
	собрать job


Step:
создается как @Bean Step
для создания есть builder

ItemReader
	специальный интерфейс для чтения item
	есть множество готовых реализаций
ItemProcessor
	принимает item, но возвращает уже другой(может и тот же), работает согласно логике
	пишем сами
ItemWiter
	записывет item куда то
	есть множество готовых реализаций
	обычно все предыдущие операции оптимизируют для записи, она сама затратная

stepBuilderFactory
	фабрика для создания билдеров для step
	ее нужно сделать @Autowired

.get
	("step_builder_name") получить от фабрики билдер с таким названием
.chunk
	(number) размер пачки которая будет передана на запись в хранилище

.reader
	(ItemReader) назначается объект для чтения

.processor
	(ItemProcessor) назначается объект для обработки
.writer
	(ItemWiter) назначается объект для записи
.build
	() создать step


JobInstance
	конкретный экзепляр job
JobExecution
	процесс выполнения job
	создается для каждого JobInstance, у одного JobInstance может быть несколько JobExecution

StepExecution
	процесс выполнения step
	создается для каждого JobExecution, у одного JobExecution может быть несколько StepExecution


JobRepository
	репозиторий для взаимодействия с хранилищем всех Job, execution и всех остальных сущностей

SimpleJobRepository
	его простая реализация
	Но может использовать непростые DAO для хранения Job-ов


JobRegistry
	позволяет динамически работать с Job
	зарегестрировать, удалять, получить список всех job, или о имени и т.д.
	он уже есть как бин в приложении

MapJobRegistry
	реализация JobRegistry

JobRegistryBeanPostProcessor
	если его объявить как @Bean то он автоматически зарегистрирует все @Job

Запуск job:
spring.batch.job.enabled: true 
	запустит все job при старте приложения, поведение по умолчанию

CommandLineJobRunner
	запуск через jar с параметрами с помощью
	сложно и в целом не очень логично

JobLauncher
	можно передать job(который создан как @Bean) и параметры и она будет запущена
	регистрирует в jobRegistry сам
	умеет только запускать

JobOperator
	принимает на вход имя job и запускает
	работает только с зарегистрированными в JobRegistry
	умеет много всего

JobExplorer
	можно узнать инфо о job, только чтение

@StepScope
	позволяет задать параметры на выполнения контреного шага, будут пересоздаваться
	работает вместе с @Value


@EnableBatchProcessing
	нужна только когда нет spring boot
	конфигурирует бины для работы с batch


Тестирование Spring Batch Test:
@SpringBatchTest
	работает вместе со @SpringBootTest
	добавляет в тесты JobRepositoryTestUtils, JobLauncherTestUtils,  StepScopeTestUtils
	добавляет для работы AssertFile для сравенения полученого результат с ожидаемым в файле
	
JobLauncherTestUtils
	содержит всего 1 job и отдает ее

JobRepositoryTestUtils
	обычно требуется очистка этого класса в контексе, делает через @BeforeEach 
		jobRepositoryTestUtils.removeJobExecution()



Монолит против микросервиса:
Монолит
	одно приложение
	включает все бизнес кейсы
+
	простые инеграции
	все в 1 месте
	легко работать с транзационностью
-
	падае сразу все
	может стать большим комом грязи
	сложно поддерживать

Микросервисы
	каждая бизнес функция это отдельный сервис
	простые коммуникации
	децентрализованное управление
	атоматизированная инфраструктура

+
	ествественное разделение сервисов
	сервисы на разных технологиях
	просто заменить сервис
	изолорованные сбои
	горизонтальная маштабируемость
-
	трудности в интеграции
	сложно правильно сделать, и не получить распределенные монолит
	больше затрат на начально этапе
	меньшя надежность


Интеграции
стратегии
	shared file system
		+ нет зависимости от отправителя и получателя, безопасность
		- низкая производительность и стойкость, зависимость от файловой системы, транзакционности нет

	database
		+ транзации
		- зависимость от бд, блокировки, маштабируемость, интернет лаги

	rest/soap
		+ независим от технологии, популярное, простота в использование
		- отправитель и получатель связаны, синхронность взаимодейсвия, доставка сообщения(гарантирована по идее)

	messaging
		+ независимость получателя и отправителя, асинхронность, маштабируемость, 
			гарантированная доставка, простота преобразования
		- время обработки и доставки не фиксированное

Messaging
	у монолита уменьшает связанность

Связанность(coupling)
	степень независимости модулей
	чем она меньше тем лучше
	делать в системе минимальное необходимое количество, тогда легко меняется и тестируется
	связанность: содежимого(один модуль зависит от особенностей другого, изменения везде),
		через общее(два модуля работают с 1 данными, изменения везде)
		через внешнее(два модуля завязаны на формате из вне, изменения везде)
		по управлению(один управляет поведением другого, изменения везде)
		по струкрурированным данным(используют общую структуру, но каждый свою часть, изменения везде)
		через данные(общие данные через параметры, элементарные данные) +
		по сообщениям(передача сообщений)+
		отсутсвие связнности(никак не взаимодействуют)+


Связность(cohesion)
	целостность модуля, насколько он прост
	чем больлше она тем лучше
	Объект обладает высокой связностью если его обязанности хорошо согласованы 
		и он не выполяет огрмных объемов работ
	типы: случайная(объединяет модуль, нет групировки)
		логическая(модули логичеки решают одну проблему)
		временная(части модуля изпользуются в одно время)
		процедурная(части модуля всегда используются в определенном порядке)
		по взаимодействию(части модуля работают над одними и теми же данными)
		по последовательности действий(результат одной части, исодные данные для другой)
		функциональная(направлены на решение одной задачи, за которую отвечает модуль)

Парадигма EIP:
	Message
		объект который содержит payload

	pipe
		соединение фильтров

	filter
		независимый узел обработки сообщения
		получает сообщение из pipe и отправляет в pipe

	endpoint
		соединения pipe и filter

аналогия:
pipes-and filters:	eip/Spring-Integration:
message			message
filter			endpoint
pipe			channel

IntegrationFlow 
	класс который позволяет создавать цепочку событий в который описываются
		необходимые интеграции: flow.handle("name_service", "name_method").handle(...)
	создается как @Bean



Spring Integration:
	реализация messaging патернов и спринг окружения
	spring boot stater integration
	работает с монолитами, что бы упростить ассинхронное взаимодействие внутри него

Базируется на: (ради чего стоит делать)
	минимальная связанность(lose coupling) для простой модульности и тестирования
	четко разделяется бизнес логика и логика интеграции
	асинхронная обработка

SEDA(stage event driven application)
	событие которое идет по стадиям и обрабатывается
	в случае spring integration события выполняются на одной машине
	kafka, mq, между сервисами
	Apache Storm(фреймфорк)
		способ ассинронной обработки
		позволяет работать с разными кластерами в рамках SEDA

Парадигма Spring Integration:
	Message
		сообщение, то что перемещается по каналу между эндпойнтами
		объект который содержит payload
		соответсвует одноименному паттерну

	channel
		то что соединяет endpoit между собой
		то по чему отправляется сообщение
		только для обмена, сам ничего не делает

	endpoint
		то что принимает информацию и отправляет ее
		то что соединяется каналами
		независимый узел обработки сообщения
		получает сообщение из channel и отправляет в channel
		их огромное множество и они выполняют разные задачи: 
			перенаправление, обработка, сбор и тд.

Классы:
Message
	содержит в себе payload(данные) и messageHeaders(адреса кому и инструкци по обработке)
		headers
			неизменяемые, считается что лучше не менять, делать копию например
	два типа паттернов сообщений: command - действия и данные для действия, 
		document - только данные
	создается через builder, сам заполняет обязательные поля по умолчанию

MessageHeader
	хранит в себе map с headers и обязательные параметры
	обязательные поля MessageHeaders: id, timestamp, reply_channel, error_channel

MessageChannel
	сообщение живет в канале пока не обработается
	inteface, 2 метода, send(message) send(message, timeout), блокирующий пока не обработает все
		timeout время за которое пытаемся поместить в канал сообщение
	виды: 
		point to point(p2p(от одного к другому)) (jms queue)
			только 1 consumer получает сообщение, выбиратся по round robin
		publisher subscriber(pub/sub) (jms topic)
			направляется всем consumer которые подписались
	классификации:
		буферизирвоанние и нет
		с опрашивающим консюмером или сами отдают информацию
		асинхронные или синхронные

PollableChannel
	interface
	имеет метод receive(получить), блокируется на нем до получения сообщения
	опрашивает, нет ли нового сообщения
	блокируется на ожидании сообщения
	основана на queque java на linkedlist
	p2p
	можно прочитать только 1 раз сообщение, 1 сообщение 1 получатель

SubscribableChannel
	interface
	имеет методы subscribe unsubscribe
	реализация паттерна listener
	pub/sub

QueueChannel
	class
	буферизированные fifo(первым пришел первым обсужен) c p2p
	когда достигает масимума по памяти то блокируется отправщик пока не освободиться место
	можно задать capacity или будет ограничен размером памяти приложения

PriorityChannel
	class на основе quequeChannel
	можно установить priority для приоритета обработки

RandezvousChannel
	class на основе quequeChannel с размером 1
	p2p небуферизированного канала
	блокирует получателя и отправителя пока не обработается сообщение

PublishSubscribeChannel
	реализация pub\sub канала MessageChannel.publishSubscribe()
	по умолчанию сам вызывает подписчиков
	можно указать минимальное кол-во подписчиков minSybscribers(), 
		нет подписчиков не принимает сообщение

DirectChannel
	MessageChannels.direct()
	p2p с subscribChannel
	выбирает 1 из подписчиков по round robin, кто первый успел взять сообщение тот и обработал

ExecutorChannel
	sub chanel со своим способом обработки

DataTypeChannel
	MessageChannels.direct().datatype(type.class)
	обычный directChannel, но разрешены только указанные типы payload

NullChannel
	канал куда сливается все что больше не нужно

ErrorChannel
	если не задан error то этот по умолчанию
	подписчиком является логер

IntegrationFlow
	interface который является service Activator
	является выходом из messaging части в не messaging 
	IntegrationFlows билдер для создания service activator
		.from указывается канал из которого взять сообщение
		.handle("class_name", "method_name") указывается класс и метод куда 
			будет передано сообщение
		.channel результат после handle положить в этот канал
		.get как build

PollerMetadata
	это инерфейс
	используется когда нужно p2p в pub\sub
	создается через @Bean(name = PollerMetadata.DEFAULT_POLLER)
	Pollers это билдер для него
		.fixedRate интервал времени в который будет опрашиватся канал


Аннотации:
@MessagingGetawey
	ставится на класс, создает эндпойнт

@Getawey
	requestChannel = "name_channel"
		указывается в какой канал отправляется информация
		name_channel это бин канала, бин канала можно передать через spel от потока
	для работы требуется поток который создается через @Bean, имя bean совпадает с name_channel
		один из вариантов MessageChannel или можно работать чрез поток 
		IntegrationFlow с его внутренними input ouptut каналами

@IntegrationComponentScan
	ставится на class с @Configuration
	подключает spring integration и запускает всю логику




@Conditional
	ConditionalOnBean   Условие выполняется, в случае если присутствует нужный бин в BeanFactory.
	ConditionalOnClass   Условие выполняется, если нужный класс есть в classpath.
	ConditionalOnCloudPlatform   Условие выполняется, когда активна определенная платформа.
	ConditionalOnExpression   Условие выполняется, когда SpEL выражение вернуло положительное значение.
	ConditionalOnJava   Условие выполняется, когда приложение запущено с определенной версией JVM.
	ConditionalOnJndi   Условие выполняется, только если через JNDI доступен определенный ресурс.
	ConditionalOnMissingBean   Условие выполняется, в случае если нужный бин отсутствует в BeanFactory.
	ConditionalOnMissingClass   Условие выполняется, если нужный класс отсутствует в classpath.
	ConditionalOnNotWebApplication   Условие выполняется, если контекст приложения не является веб контекстом.
	ConditionalOnProperty   Условие выполняется, если в файле настроек заданы нужные параметры.
	ConditionalOnResource   Условие выполняется, если присутствует нужный ресурс в classpath.
	ConditionalOnSingleCandidate   Условие выполняется, если bean-компонент указанного класса уже содержится в BeanFactory и он единственный.
	ConditionalOnWebApplication   Условие выполняется, если контекст приложения является веб контекстом.
